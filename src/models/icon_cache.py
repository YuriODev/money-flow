"""Icon cache model for storing fetched and AI-generated icons.

This module provides the IconCache model for caching service icons from various
sources (SimpleIcons, Clearbit, AI-generated) with proper metadata and TTL support.

The cache supports:
- External icon URLs from CDNs (SimpleIcons, Clearbit, Logo.dev)
- AI-generated icons (stored as base64 or URLs)
- User-uploaded custom icons
- Automatic expiration based on source

Example:
    >>> from src.models.icon_cache import IconCache, IconSource
    >>> icon = IconCache(
    ...     service_name="netflix",
    ...     source=IconSource.SIMPLE_ICONS,
    ...     icon_url="https://cdn.simpleicons.org/netflix/E50914",
    ...     brand_color="#E50914",
    ... )
"""

from datetime import UTC, datetime, timedelta
from enum import Enum
from typing import TYPE_CHECKING
from uuid import uuid4

from sqlalchemy import DateTime, ForeignKey, Index, Integer, String, Text
from sqlalchemy import Enum as SQLEnum
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.db.database import Base

if TYPE_CHECKING:
    from src.models.user import User


class IconSource(str, Enum):
    """Source of the icon.

    Attributes:
        SIMPLE_ICONS: From SimpleIcons CDN (svg icons).
        CLEARBIT: From Clearbit Logo API.
        LOGO_DEV: From Logo.dev API.
        BRANDFETCH: From Brandfetch API.
        AI_GENERATED: Generated by AI (DALL-E, Stable Diffusion).
        USER_UPLOADED: Uploaded by user.
        FALLBACK: Generic fallback icon.
    """

    SIMPLE_ICONS = "simple_icons"
    CLEARBIT = "clearbit"
    LOGO_DEV = "logo_dev"
    BRANDFETCH = "brandfetch"
    AI_GENERATED = "ai_generated"
    USER_UPLOADED = "user_uploaded"
    FALLBACK = "fallback"


# TTL defaults by source (in hours)
SOURCE_TTL_HOURS = {
    IconSource.SIMPLE_ICONS: 24 * 7,  # 7 days (stable CDN)
    IconSource.CLEARBIT: 24 * 3,  # 3 days
    IconSource.LOGO_DEV: 24 * 3,  # 3 days
    IconSource.BRANDFETCH: 24 * 7,  # 7 days
    IconSource.AI_GENERATED: 24 * 30,  # 30 days (expensive to regenerate)
    IconSource.USER_UPLOADED: 24 * 365,  # 1 year (permanent)
    IconSource.FALLBACK: 24,  # 1 day (refresh frequently)
}


class IconCache(Base):
    """Cached icon for a service.

    Stores icons from various sources with metadata for efficient retrieval
    and automatic expiration. Supports both public icons and user-specific
    custom icons.

    Attributes:
        id: Unique identifier (UUID).
        service_name: Normalized service name (lowercase, no spaces).
        display_name: Human-readable service name.
        source: Source of the icon (CDN, AI, user).
        icon_url: URL to the icon (CDN or stored).
        icon_data: Base64 encoded icon data (for AI/uploaded).
        brand_color: Primary brand color (hex).
        secondary_color: Secondary brand color (hex).
        category: Service category.
        width: Icon width in pixels.
        height: Icon height in pixels.
        format: Image format (svg, png, webp).
        user_id: Owner user ID (null for global cache).
        created_at: When the cache entry was created.
        updated_at: When the cache entry was last updated.
        expires_at: When the cache entry expires.
        fetch_count: Number of times this icon was fetched.
        last_fetched_at: When the icon was last fetched.
        is_verified: Whether the icon was verified by admin.

    Example:
        >>> icon = IconCache(
        ...     service_name="spotify",
        ...     display_name="Spotify",
        ...     source=IconSource.SIMPLE_ICONS,
        ...     icon_url="https://cdn.simpleicons.org/spotify/1DB954",
        ...     brand_color="#1DB954",
        ... )
    """

    __tablename__ = "icon_cache"

    # Primary key
    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4()),
    )

    # Service identification
    service_name: Mapped[str] = mapped_column(
        String(100),
        nullable=False,
        index=True,
        comment="Normalized service name (lowercase)",
    )
    display_name: Mapped[str | None] = mapped_column(
        String(200),
        nullable=True,
        comment="Human-readable service name",
    )

    # Icon source and data
    source: Mapped[IconSource] = mapped_column(
        SQLEnum(IconSource, name="iconsource"),
        nullable=False,
        default=IconSource.FALLBACK,
    )
    icon_url: Mapped[str | None] = mapped_column(
        String(1000),
        nullable=True,
        comment="URL to the icon",
    )
    icon_data: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        comment="Base64 encoded icon data",
    )

    # Brand metadata
    brand_color: Mapped[str | None] = mapped_column(
        String(7),
        nullable=True,
        comment="Primary brand color (hex)",
    )
    secondary_color: Mapped[str | None] = mapped_column(
        String(7),
        nullable=True,
        comment="Secondary brand color (hex)",
    )
    category: Mapped[str | None] = mapped_column(
        String(50),
        nullable=True,
        comment="Service category",
    )

    # Image metadata
    width: Mapped[int | None] = mapped_column(
        Integer,
        nullable=True,
        comment="Icon width in pixels",
    )
    height: Mapped[int | None] = mapped_column(
        Integer,
        nullable=True,
        comment="Icon height in pixels",
    )
    format: Mapped[str | None] = mapped_column(
        String(10),
        nullable=True,
        default="svg",
        comment="Image format (svg, png, webp)",
    )

    # Ownership (null = global cache)
    user_id: Mapped[str | None] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=True,
        index=True,
        comment="Owner user ID (null for global cache)",
    )

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(UTC),
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        default=lambda: datetime.now(UTC),
        onupdate=lambda: datetime.now(UTC),
    )
    expires_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        comment="When the cache entry expires",
    )

    # Usage tracking
    fetch_count: Mapped[int] = mapped_column(
        Integer,
        default=0,
        comment="Number of times this icon was fetched",
    )
    last_fetched_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        comment="When the icon was last fetched",
    )

    # Admin verification
    is_verified: Mapped[bool] = mapped_column(
        default=False,
        comment="Whether the icon was verified by admin",
    )

    # Relationships
    user: Mapped["User | None"] = relationship(
        "User",
        back_populates="cached_icons",
        lazy="selectin",
    )

    # Indexes
    __table_args__ = (
        Index(
            "ix_icon_cache_service_user",
            "service_name",
            "user_id",
            unique=True,
        ),
        Index(
            "ix_icon_cache_source_expires",
            "source",
            "expires_at",
        ),
    )

    def __repr__(self) -> str:
        """Return string representation."""
        return f"<IconCache(service={self.service_name}, source={self.source.value})>"

    @property
    def is_expired(self) -> bool:
        """Check if the cache entry is expired.

        Returns:
            True if expired or no expiration set.
        """
        if self.expires_at is None:
            return False
        return datetime.now(UTC) > self.expires_at

    @property
    def is_global(self) -> bool:
        """Check if this is a global cache entry.

        Returns:
            True if no user_id (global cache).
        """
        return self.user_id is None

    def set_expiry_from_source(self) -> None:
        """Set expiry based on the icon source.

        Uses SOURCE_TTL_HOURS mapping to determine TTL.
        """
        ttl_hours = SOURCE_TTL_HOURS.get(self.source, 24)
        self.expires_at = datetime.now(UTC) + timedelta(hours=ttl_hours)

    def record_fetch(self) -> None:
        """Record that this icon was fetched.

        Updates fetch_count and last_fetched_at.
        """
        self.fetch_count += 1
        self.last_fetched_at = datetime.now(UTC)

    def refresh(self, icon_url: str | None = None, icon_data: str | None = None) -> None:
        """Refresh the cache entry with new data.

        Args:
            icon_url: New icon URL.
            icon_data: New base64 icon data.
        """
        if icon_url:
            self.icon_url = icon_url
        if icon_data:
            self.icon_data = icon_data
        self.updated_at = datetime.now(UTC)
        self.set_expiry_from_source()
